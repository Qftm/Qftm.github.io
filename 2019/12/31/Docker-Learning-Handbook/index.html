<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Docker Learning Handbook, Qftm">
    <meta name="description" content="Maybe a hacker">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Docker Learning Handbook | Qftm</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Qftm</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-heartbeat" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Qftm</div>
        <div class="logo-desc">
            
            Maybe a hacker
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-heartbeat"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/banner/bg.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Docker Learning Handbook</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Handbook/">
                                <span class="chip bg-color">Handbook</span>
                            </a>
                        
                            <a href="/tags/Docker/">
                                <span class="chip bg-color">Docker</span>
                            </a>
                        
                            <a href="/tags/Cloud/">
                                <span class="chip bg-color">Cloud</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/" class="post-category">
                                安全建设
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2019-12-31
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2022-03-15
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    24.6k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>Read Times:&nbsp;&nbsp;
                    95 Min
                </div>
                

                
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Docker-Learning-Handbook"><a href="#Docker-Learning-Handbook" class="headerlink" title="Docker Learning Handbook"></a>Docker Learning Handbook</h1><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><pre><code> Author：Qftm
 Data：2019/12/31
 Blog：https://qftm.github.io/</code></pre><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200405210845829.png" alt="image-20200405210845829"></p>
<h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ul>
<li><a href="#docker-简介">Docker 简介</a></li>
<li><a href="#docker-资源">Docker 资源</a></li>
<li><a href="#docker-优点">Docker 优点</a></li>
<li><a href="#docker-组成">Docker 组成</a><ul>
<li><a href="#cs">C/S</a></li>
<li><a href="#镜像">镜像</a></li>
<li><a href="#容器">容器</a></li>
<li><a href="#仓库">仓库</a></li>
</ul>
</li>
<li><a href="#docker-安装">Docker 安装</a><ul>
<li><a href="#各个系统安装">各个系统安装</a></li>
<li><a href="#镜像加速器">镜像加速器</a><ul>
<li><a href="#docker-官方镜像加速器">Docker 官方镜像加速器</a></li>
<li><a href="#daocloud-镜像加速器">DaoCloud 镜像加速器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#docker-镜像使用">Docker 镜像使用</a><ul>
<li><a href="#获取仓库镜像">获取仓库镜像</a></li>
<li><a href="#列出本地镜像">列出本地镜像</a></li>
<li><a href="#删除本地镜像">删除本地镜像</a></li>
<li><a href="#构建镜像">构建镜像</a><ul>
<li><a href="#理解-commit-构建镜像">理解 commit 构建镜像</a></li>
<li><a href="#使用-dockerfile-构建镜像">使用 dockerfile 构建镜像</a><ul>
<li><a href="#from-指定基础镜像">FROM 指定基础镜像</a></li>
<li><a href="#run-执行命令">RUN 执行命令</a></li>
<li><a href="#构建镜像-1">构建镜像</a></li>
<li><a href="#镜像构建上下文context">镜像构建上下文（Context）</a></li>
<li><a href="#其它-docker-build-的用法">其它 <code>docker build</code> 的用法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#dockerfile-详解">Dockerfile 详解</a><ul>
<li><a href="#copy-复制文件">COPY 复制文件</a></li>
<li><a href="#add-更高级的复制文件">ADD 更高级的复制文件</a></li>
<li><a href="#cmd-容器启动命令">CMD 容器启动命令</a></li>
<li><a href="#entrypoint-入口点">ENTRYPOINT 入口点</a></li>
<li><a href="#env-设置环境变量">ENV 设置环境变量</a></li>
<li><a href="#arg-构建参数">ARG 构建参数</a></li>
<li><a href="#volume-定义匿名卷">VOLUME 定义匿名卷</a></li>
<li><a href="#expose-声明端口">EXPOSE 声明端口</a></li>
<li><a href="#workdir-指定工作目录">WORKDIR 指定工作目录</a></li>
<li><a href="#user-指定当前用户">USER 指定当前用户</a></li>
<li><a href="#healthcheck-健康检查">HEALTHCHECK 健康检查</a></li>
<li><a href="#onbuild-为他人做嫁衣裳">ONBUILD 为他人做嫁衣裳</a></li>
</ul>
</li>
<li><a href="#dockerfile-定制-lamp">Dockerfile 定制 LAMP</a><ul>
<li><a href="#需求分析">需求分析</a></li>
<li><a href="#定制脚本">定制脚本</a></li>
<li><a href="#容器测试">容器测试</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#docker-容器操作">Docker 容器操作</a><ul>
<li><a href="#启动创建容器">启动创建容器</a><ul>
<li><a href="#新建容器启动">新建容器启动</a><ul>
<li><a href="#非交互式容器">非交互式容器</a></li>
<li><a href="#交互式容器">交互式容器</a></li>
</ul>
</li>
<li><a href="#启动已终止容器">启动已终止容器</a></li>
</ul>
</li>
<li><a href="#守护式容器">守护式容器</a><ul>
<li><a href="#交互式容器转入后台">交互式容器转入后台</a></li>
<li><a href="#非交互式容器转入后台">非交互式容器转入后台</a></li>
</ul>
</li>
<li><a href="#导出与导入">导出与导入</a><ul>
<li><a href="#导出容器快照">导出容器快照</a></li>
<li><a href="#导入容器快照">导入容器快照</a></li>
</ul>
</li>
<li><a href="#删除容器">删除容器</a></li>
<li><a href="#网络管理">网络管理</a><ul>
<li><a href="#端口映射">端口映射</a></li>
</ul>
</li>
<li><a href="#数据管理">数据管理</a><ul>
<li><a href="#数据卷">数据卷</a></li>
<li><a href="#挂载主机目录">挂载主机目录</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#docker-仓库管理">Docker 仓库管理</a><ul>
<li><a href="#docker-hub">Docker Hub</a><ul>
<li><a href="#注册">注册</a></li>
<li><a href="#登录">登录</a></li>
<li><a href="#拉取镜像">拉取镜像</a></li>
<li><a href="#推送镜像">推送镜像</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#docker-底层实现">Docker 底层实现</a><ul>
<li><a href="#命名空间">命名空间</a></li>
<li><a href="#控制组">控制组</a></li>
<li><a href="#联合文件系统">联合文件系统</a></li>
</ul>
</li>
<li><a href="#docker-安全机制">Docker 安全机制</a></li>
<li><a href="#references">References</a></li>
</ul>
<h1 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h1><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 <a href="https://en.wikipedia.org/wiki/Docker_(software)" target="_blank" rel="noopener">2013 年 3 月以 Apache 2.0 授权协议开源</a>，主要项目代码在 <a href="https://github.com/moby/moby" target="_blank" rel="noopener">GitHub</a> 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 <a href="https://www.opencontainers.org/" target="_blank" rel="noopener">开放容器联盟（OCI）</a>。</p>
<p>Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，<a href="https://blog.docker.com/2013/10/dotcloud-is-becoming-docker-inc/" target="_blank" rel="noopener">dotCloud 公司决定改名为 Docker</a>。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。</p>
<p>Docker 使用 Google 公司推出的 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 进行开发实现，基于 Linux 内核的 <a href="https://zh.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroups</a>，<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">namespace</a>，以及 <a href="https://en.wikipedia.org/wiki/Aufs" target="_blank" rel="noopener">AUFS</a> 类的 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 等技术，对进程进行封装隔离，属于 <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization" target="_blank" rel="noopener">操作系统层面的虚拟化技术</a>。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 <a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">LXC</a>，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC</a> 和 <a href="https://github.com/containerd/containerd" target="_blank" rel="noopener">containerd</a>。</p>
<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<p>下面的一张图比较了 Docker 和传统虚拟化方式的不同之处(官方图例)。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200405182934013.png" alt="image-20200405182934013"></p>
<h1 id="Docker-资源"><a href="#Docker-资源" class="headerlink" title="Docker 资源"></a>Docker 资源</h1><p>Docker 官方主页</p>
<pre><code>https://www.docker.com</code></pre><p>Docker 官方博客</p>
<pre><code>https://blog.docker.com/</code></pre><p>Docker 官方文档</p>
<pre><code>https://docs.docker.com/</code></pre><p>Docker Hub</p>
<pre><code>https://hub.docker.com</code></pre><p>Docker Github Repositories</p>
<pre><code>https://github.com/docker</code></pre><p>Docker Engine API</p>
<pre><code>https://docs.docker.com/engine/api/sdk/</code></pre><p>Docker 发布版本历史</p>
<pre><code>https://docs.docker.com/release-notes/</code></pre><p>Docker 常见问题</p>
<pre><code>https://docs.docker.com/engine/faq/</code></pre><h1 id="Docker-优点"><a href="#Docker-优点" class="headerlink" title="Docker 优点"></a>Docker 优点</h1><p><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a> 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的维护效率，降低了云计算应用开发的成本！使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！</p>
<ul>
<li><strong>更高效的利用系统资源</strong></li>
</ul>
<p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>
<ul>
<li><strong>更快速的启动时间</strong></li>
</ul>
<p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
<ul>
<li><strong>一致的运行环境</strong></li>
</ul>
<p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 <em>「这段代码在我机器上没问题啊」</em> 这类问题。</p>
<ul>
<li><strong>持续交付和部署</strong></li>
</ul>
<p>对开发和运维（<a href="https://zh.wikipedia.org/wiki/DevOps" target="_blank" rel="noopener">DevOps</a>）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>
<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过Dockerfile来进行镜像构建，并结合 <a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="noopener">持续集成(Continuous Integration)</a> 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 <a href="https://en.wikipedia.org/wiki/Continuous_delivery" target="_blank" rel="noopener">持续部署(Continuous Delivery/Deployment)</a> 系统进行自动部署。</p>
<p>而且使用 <code>Dockerfile</code> 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>
<ul>
<li><strong>更轻松的迁移</strong></li>
</ul>
<p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<ul>
<li><strong>更轻松的维护和扩展</strong></li>
</ul>
<p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 <a href="https://hub.docker.com/search/?type=image&image_filter=official" target="_blank" rel="noopener">官方镜像</a>，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>
<ul>
<li><strong>对比传统虚拟机</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">容器</th>
<th align="left">虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td align="left">启动</td>
<td align="left">秒级</td>
<td align="left">分钟级</td>
</tr>
<tr>
<td align="left">硬盘使用</td>
<td align="left">一般为 <code>MB</code></td>
<td align="left">一般为 <code>GB</code></td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">接近原生</td>
<td align="left">弱于</td>
</tr>
<tr>
<td align="left">系统支持量</td>
<td align="left">单机支持上千个容器</td>
<td align="left">一般几十个</td>
</tr>
</tbody></table>
<h1 id="Docker-组成"><a href="#Docker-组成" class="headerlink" title="Docker 组成"></a>Docker 组成</h1><p>Docker 包括一下几个部分</p>
<ul>
<li>客户端（<code>Client</code>）</li>
<li>守护进程（<code>Daemon</code>）</li>
<li>镜像（<code>Image</code>）</li>
<li>容器（<code>Container</code>）</li>
<li>仓库（<code>Repository</code>）</li>
</ul>
<p>理解了这几个概念，就理解了 Docker 的整个生命周期，下面这幅图展示了Docker的组成：</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200406101727486.png" alt="image-20200406101727486"></p>
<h2 id="C-S"><a href="#C-S" class="headerlink" title="C/S"></a>C/S</h2><p><code>Docker</code> 使用了 <code>C/S</code> 体系架构，<code>Docker client</code> 客户端与 <code>Docker daemon</code> 守护进程服务端通信，<code>Docker</code> 守护进程负责构建，运行和分发 <code>Docker</code> 容器。<code>Docker</code> 客户端和守护进程可以在同一个系统上运行，也可以将 <code>Docker</code> 客户端连接到远程<code>Docker</code> 守护进程，其中客户端和服务端通信 <code>Docker API</code> 起到重要角色。</p>
<p><code>Docker API</code> 遵循 <code>RESTful API</code> 标准（基于 HTTP 协议），可由 HTTP 客户端（如 wget 或 curl）或作为大多数现代编程语言的 HTTP 库访问，官方提供的主要有三大 API：</p>
<pre><code>Docker Engine API     # https://docs.docker.com/engine/api/
Docker Hub API        # https://docs.docker.com/docker-hub/api/latest/
Docker Registry API   # https://docs.docker.com/registry/spec/api/</code></pre><ul>
<li>Client/Server</li>
</ul>
<p>Docker的使用者并不会直接与Docker守护进程接触，而是由Docker客户端进行交互。</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200407162139749.png" alt="image-20200407162139749"></p>
<ul>
<li>Engine API</li>
</ul>
<p><code>Docker</code> 提供了一个用于与 <code>Docker</code> 守护进程进行交互的 <a href="https://docs.docker.com/engine/api/" target="_blank" rel="noopener">API</a>（称为 <code>Docker Engine API</code>），以及Go和Python等语言的SDK。使用SDK，您可以快速轻松地构建与扩展Docker应用程序和解决方案。</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200407162639411.png" alt="image-20200407162639411"></p>
<p><code>Docker Engine API</code> 个版本 HTTP 接口详情见官网 <a href="https://docs.docker.com/engine/api/" target="_blank" rel="noopener">Engine API reference </a> </p>
<p><code>Docker Client</code> 与 <code>Docker Server</code>（<code>Docker daemon</code>）的连接方式主要是通过 <code>Socket</code> 进行连接，<code>Docker daemon</code> 支持如下三种不同类型的 <code>Socket</code></p>
<pre><code>unix:///var/run/docker.sock
tcp://host:port
fd://socketfd</code></pre><p><code>Docker daemon</code> 默认监听 <code>unix:///var/run/docker.sock</code> ，也可以通过 <code>-H</code> 参数设置监听其它 <code>unix socket</code> 或 <code>tcp socket</code> 等。</p>
<p>用户可以利用CLI（docker本身）或者自定义程序调用 Engine API 与 DockerServer 建立Socket连接，通过 Socket 可以在本地或者远程(配置<code>docker -H</code>参数)和DokcerServer建立通信。</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200407163404087.png" alt="image-20200407163404087"></p>
<ul>
<li>本地/远程(host)</li>
</ul>
<p>Docker客户端和守护进程可以在同一个系统上运行，也可以将Docker客户端连接到远程Docker守护进程。</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200406102156907.png" alt="image-20200406102156907"></p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 <code>root</code> 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 <code>root</code> 文件系统。比如官方镜像 <code>ubuntu:18.04</code> 就包含了完整的一套 Ubuntu 18.04 最小系统的 <code>root</code> 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<ul>
<li><strong>分层存储</strong></li>
</ul>
<p>因为镜像包含操作系统完整的 <code>root</code> 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount" target="_blank" rel="noopener">Union FS</a> 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200406102230056.png" alt="image-20200406102230056"></p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<table>
<thead>
<tr>
<th align="left">Docker</th>
<th align="left">面向对象</th>
</tr>
</thead>
<tbody><tr>
<td align="left">容器</td>
<td align="left">对象(实例)</td>
</tr>
<tr>
<td align="left">镜像</td>
<td align="left">类</td>
</tr>
</tbody></table>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写（写时复制）而准备的存储层为<strong>容器存储层</strong>。</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200406103206422.png" alt="image-20200406103206422"></p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p>
<p>一个 <strong>Docker Registry</strong> 中可以包含多个<strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个<strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p>
<p>以 <a href="https://hub.docker.com/_/ubuntu" target="_blank" rel="noopener">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>16.04</code>, <code>18.04</code>。我们可以通过 <code>ubuntu:14.04</code>，或者 <code>ubuntu:18.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p>
<p>仓库名经常以 <em>两段式路径</em> 形式出现，比如 <code>jwilder/nginx-proxy</code>，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<ul>
<li><strong>Docker Registry 公开服务</strong></li>
</ul>
<p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 <a href="https://coreos.com/" target="_blank" rel="noopener">CoreOS</a> 的 <a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a>，CoreOS 相关的镜像存储在这里；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a>，<a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 的镜像使用的就是这个服务。</p>
<p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（<code>Registry Mirror</code>），这些镜像服务被称为<strong>加速器</strong>。常见的有 <a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。</p>
<p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">时速云镜像仓库</a>、<a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云镜像库</a> 等。</p>
<ul>
<li><strong>Docker Registry 私有服务</strong></li>
</ul>
<p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://hub.docker.com/_/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。</p>
<p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a> 的服务端实现，足以支持 <code>docker</code> 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="noopener">Docker Trusted Registry</a> 中，提供了这些高级功能。</p>
<p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">VMWare Harbor</a> 和 Sonatype Nexus。</p>
<h1 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h1><h2 id="各个系统安装"><a href="#各个系统安装" class="headerlink" title="各个系统安装"></a>各个系统安装</h2><ul>
<li>官方详细手册</li>
</ul>
<pre><code>https://docs.docker.com/</code></pre><ul>
<li>Docker for Linux</li>
</ul>
<pre><code>https://docs.docker.com/install/linux/docker-ce/ubuntu/</code></pre><ul>
<li>Docker Desktop for Mac</li>
</ul>
<pre><code>https://docs.docker.com/docker-for-mac/install/</code></pre><ul>
<li>Docker Desktop for Windows</li>
</ul>
<pre><code>https://docs.docker.com/docker-for-windows/install/</code></pre><h2 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h2><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商等都提供了国内加速器服务，例如：</p>
<ul>
<li><a href="https://registry.docker-cn.com" target="_blank" rel="noopener">docker官方镜像加速器</a></li>
<li><a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">daocloud镜像加速器</a></li>
<li><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">阿里云加速器(需登录账号获取)</a></li>
<li><a href="https://docker.mirrors.ustc.edu.cn" target="_blank" rel="noopener">ustc 的镜像</a></li>
<li><a href="http://hub-mirror.c.163.com/" target="_blank" rel="noopener">网易</a></li>
</ul>
<pre><code>Note:
当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。
国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。</code></pre><h3 id="Docker-官方镜像加速器"><a href="#Docker-官方镜像加速器" class="headerlink" title="Docker 官方镜像加速器"></a>Docker 官方镜像加速器</h3><ul>
<li>Ubuntu 14.04、Debian 7 Wheezy</li>
</ul>
<p>对于使用 <a href="http://upstart.ubuntu.com/" target="_blank" rel="noopener">upstart</a> 的系统而言，编辑 <code>/etc/default/docker</code> 文件，在其中的 <code>DOCKER_OPTS</code> 中配置加速器地址：</p>
<pre class="line-numbers language-bash"><code class="language-bash">DOCKER_OPTS<span class="token operator">=</span><span class="token string">"--registry-mirror=https://registry.docker-cn.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>重新启动服务。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">service</span> docker restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li>Ubuntu 16.04+、Debian 8+、CentOS 7</li>
</ul>
<p>对于使用 <a href="https://www.freedesktop.org/wiki/Software/systemd/" target="_blank" rel="noopener">systemd</a> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p>
<pre class="line-numbers language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"registry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">"https://registry.docker-cn.com"</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>PS：注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p>
<p>之后重新启动服务。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">sudo</span> systemctl daemon-reload
$ <span class="token function">sudo</span> systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>Windows 10</li>
</ul>
<p>对于使用 Windows 10 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 <code>Settings</code>，打开配置窗口后左侧导航菜单选择 <code>Daemon</code>。在 <code>Registry mirrors</code> 一栏中填写加速器地址 <code>https://registry.docker-cn.com</code>，之后点击 <code>Apply</code> 保存后 Docker 就会重启并应用配置的镜像地址了。</p>
<ul>
<li>macOS</li>
</ul>
<p>对于使用 macOS 的用户，在任务栏点击 Docker for mac 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址 <code>https://registry.docker-cn.com</code>。修改完成之后，点击 <code>Apply &amp; Restart</code> 按钮，Docker 就会重启并应用配置的镜像地址了。</p>
<ul>
<li>检查加速器是否生效</li>
</ul>
<p>命令行执行 <code>docker info</code>，如果从结果中看到了如下内容，说明配置成功。</p>
<pre class="line-numbers language-bash"><code class="language-bash">Registry Mirrors:
 https://registry.docker-cn.com/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="DaoCloud-镜像加速器"><a href="#DaoCloud-镜像加速器" class="headerlink" title="DaoCloud 镜像加速器"></a>DaoCloud 镜像加速器</h3><p>下面不同系统的部署配置方法来自官方描述：<a href="https://www.daocloud.io/mirror" target="_blank" rel="noopener">配置 Docker 镜像站</a></p>
<ul>
<li>Linux</li>
</ul>
<pre><code>curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</code></pre><p>该脚本可以将 –registry-mirror 加入到你的 Docker 配置文件 /etc/docker/daemon.json 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。更多详情请访问文档。</p>
<ul>
<li>macOS</li>
</ul>
<p>Docker For Mac</p>
<p>右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Daemon 标签（Docker 17.03 之前版本为 Advanced 标签）下的 Registry mirrors 列表中加入下面的镜像地址:</p>
<pre><code>http://f1361db2.m.daocloud.io</code></pre><p>点击 Apply &amp; Restart 按钮使设置生效。</p>
<p>Docker Toolbox 等配置方法请参考<a href="http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox" target="_blank" rel="noopener">帮助文档</a>。</p>
<ul>
<li>Windows</li>
</ul>
<p>Docker For Windows</p>
<p>在桌面右下角状态栏中右键 docker 图标，修改在 Docker Daemon 标签页中的 json ，把下面的地址:</p>
<pre><code>http://f1361db2.m.daocloud.io</code></pre><p>加到” <code>registry-mirrors</code>“的数组里。点击 Apply 。</p>
<p>Docker Toolbox 等配置方法请参考<a href="http://guide.daocloud.io/dcs/daocloud-9153151.html#docker-toolbox" target="_blank" rel="noopener">帮助文档</a>。</p>
<h1 id="Docker-镜像使用"><a href="#Docker-镜像使用" class="headerlink" title="Docker 镜像使用"></a>Docker 镜像使用</h1><h2 id="获取仓库镜像"><a href="#获取仓库镜像" class="headerlink" title="获取仓库镜像"></a>获取仓库镜像</h2><p>前面提到过，<a href="https://hub.docker.com/search?q=&type=image" target="_blank" rel="noopener">Docker Hub</a> 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p>
<p>一般情况下我们可以在本地终端使用<code>docker search</code> 来搜索相关镜像（搜索指定软件名的镜像），但是有一个缺点就是搜索的结果不包含<code>Tag</code>也就导致我们无法使用<code>docker pull</code>下载相应的镜像。</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200406190916891.png" alt="image-20200406190916891"></p>
<p>这个时候只能在<a href="https://hub.docker.com/search?q=&type=image" target="_blank" rel="noopener">Docker Hub</a> 上进行搜索然后根据显示的<code>TAG</code>在使用<code>docker pull</code>下载相应的镜像。</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200406191042497.png" alt="image-20200406191042497"></p>
<p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker pull <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>Docker Registry 地址<span class="token punctuation">[</span>:端口号<span class="token punctuation">]</span>/<span class="token punctuation">]</span>仓库名<span class="token punctuation">[</span>:标签<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 Docker Hub。</li>
<li>仓库名：这里的仓库名是两段式名称，即 <code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li>
<li>镜像名：由仓库名和标签组成，标志了每一个镜像。</li>
</ul>
<p>Example：</p>
<pre class="line-numbers language-bash"><code class="language-bash">root@rose:~<span class="token comment" spellcheck="true"># docker pull ubuntu:18.04</span>
18.04: Pulling from library/ubuntu
5bed26d33875: Pull complete
f11b29a9c730: Pull complete
930bda195c84: Pull complete
78bf9a5ad49e: Pull complete
Digest: sha256:bec5a2727be7fff3d308193cfde3491f8fba1a2ba392b7546b43a051853a341d
Status: Downloaded newer image <span class="token keyword">for</span> ubuntu:18.04<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。</p>
<p>如果在<code>docker pull</code>中没有指定<code>Tag</code>则默认会下载标签为<code>latest</code>的镜像文件。</p>
<p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p>
<p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 <code>sha256</code> 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p>
<h2 id="列出本地镜像"><a href="#列出本地镜像" class="headerlink" title="列出本地镜像"></a>列出本地镜像</h2><ul>
<li><strong>查看本地镜像</strong></li>
</ul>
<p>可以使用 <code>docker image ls</code> 或<code>docker images</code>命令列出已经下载下来的镜像。</p>
<p>这两个命令语法类似</p>
<pre><code>docker images [OPTSIONS] [REPOSITORY]
    -a, --all=false
    -f, --filter=[]    #镜像过滤显示
    --no-trunc=false   #镜像ID不截断显示
    -q, --quiet=false</code></pre><p>查看本地下载镜像</p>
<pre><code>root@rose:~# docker image ls
REPOSITORY      TAG              IMAGE ID            CREATED            SIZE
ubuntu         18.04            4e5021d210f6        2 weeks ago         64.2MB
ubuntu         latest           4e5021d210f6        2 weeks ago         64.2MB
mongo           3.2             fe9198c04d62        5 days ago          342 MB
&lt;none&gt;         &lt;none&gt;           00285df0df87        5 days ago          342 MB</code></pre><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p>
<p>镜像 ID (sha值)是镜像的唯一标识，一个镜像可以对应多个标签。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:latest</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p>
<p>查看本地镜像详细信息</p>
<pre><code>docker image inspect 镜像名或镜像ID
or
docker inspect 镜像名或镜像ID</code></pre><p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200406231617576.png" alt="image-20200406231617576"></p>
<ul>
<li><strong>虚悬镜像</strong></li>
</ul>
<p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none&gt;</code>。：</p>
<pre><code>&lt;none&gt;         &lt;none&gt;           00285df0df87        5 days ago          342 MB</code></pre><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none&gt;</code>。除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none&gt;</code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker image <span class="token function">ls</span> -f dangling<span class="token operator">=</span>true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除所有虚悬镜像：</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker image prune<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 或<code>docker rmi</code>命令，其格式为：</p>
<pre><code>docker rmi [OPTIONS] IMAGE [IMAGE...]
or
docker image rm [OPTIONS] IMAGE [IMAGE...]</code></pre><p>用 ID、镜像名、摘要删除镜像。其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200406232524927.png" alt="image-20200406232524927"></p>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>一般情况下不会使用 <code>docker commit</code> 定制镜像，定制镜像应该使用 <code>Dockerfile</code> 来完成。因为<code>docker commit</code>定制的镜像相当于黑箱操作，外界不知道这个镜像做了哪些操作，不便于维护，而且由于其在容器的存储层上进行的修改，后期在其基础上进行修改不会导致上一层的内容真实的去除，也就导致制作的镜像变得更加臃肿。事实上<code>docker commit</code>这种方式定制的镜像和下面在容器里面所讲述的容器快照导出与导入作为一个镜像是类似的都是在容器的存储层进行了修改。而使用<code>dockerfile</code>制作的镜像是透明的，把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，也就方便后期的维护。下面主要了解一下这两种模式是怎么定制镜像的。</p>
<h3 id="理解-commit-构建镜像"><a href="#理解-commit-构建镜像" class="headerlink" title="理解 commit 构建镜像"></a>理解 commit 构建镜像</h3><p>镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p>
<p>现在以一个简单的例子定制一个容器，存储一个文件<code>Qftm.txt</code>，文件内容<code>hello word</code>，然后将其定制为一个镜像。</p>
<pre><code>root@rose:~# docker run -it ubuntu:18.04 bash
root@c38db96c2fda:/# touch Qftm.txt
root@c38db96c2fda:/# echo &quot;hello word&quot;&gt;Qftm.txt
root@c38db96c2fda:/# cat Qftm.txt
hello word
root@c38db96c2fda:/#</code></pre><p>制作操作之后，我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 <code>docker diff</code> 命令看到具体的改动。</p>
<pre><code>root@rose:~# docker diff c38db96c2fda
C /root
A /root/.bash_history
A /Qftm.txt
root@rose:~#</code></pre><p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p>
<p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 <code>docker commit</code> 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>
<p><code>docker commit</code> 的语法格式为：</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker commit <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token operator">&lt;</span>容器ID或容器名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>仓库名<span class="token operator">></span><span class="token punctuation">[</span>:<span class="token operator">&lt;</span>标签<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们可以用下面的命令将容器保存为镜像：</p>
<pre><code>root@rose:~# docker commit --author &quot;Qftm&quot; --message &quot;txt file&quot; c38db96c2fda ubuntu:v1
sha256:35e3740b9fa34d7a2bddc488356073ebacd3c44f69f2633bf08a48685a5656aa
root@rose:~#</code></pre><p>其中 <code>--author</code> 是指定修改的作者，而 <code>--message</code> 则是记录本次修改的内容。这点和 <code>git</code> 版本控制相似，不过这里这些信息可以省略留空。</p>
<p>我们可以在 <code>docker image ls</code> 中看到这个新定制的镜像：</p>
<pre><code>root@rose:~# docker image ls
REPOSITORY    TAG                 IMAGE ID            CREATED           SIZE
ubuntu         v1               35e3740b9fa3        30 seconds ago      64.2MB</code></pre><p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>ubuntu:18.04</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200407160927685.png" alt="image-20200407160927685"></p>
<p>到这里新的镜像已经定制好了，可以运行这个镜像创建容器。最后要说的还是尽量不要用这种方法去定制镜像，缺点已经在上面讲过了。虽然使用 <code>docker commit</code> 命令可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p>
<h3 id="使用-dockerfile-构建镜像"><a href="#使用-dockerfile-构建镜像" class="headerlink" title="使用 dockerfile 构建镜像"></a>使用 dockerfile 构建镜像</h3><p>从刚才的 <code>docker commit</code> 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的 <strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>这里以简单定制nginx镜像为例，使用Dockerfile来定制</p>
<p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p>
<pre class="line-numbers language-bash"><code class="language-bash">root@rose:~<span class="token comment" spellcheck="true"># mkdir mynginx</span>
root@rose:~<span class="token comment" spellcheck="true"># cd mynginx</span>
root@rose:~/mynginx<span class="token comment" spellcheck="true"># touch Dockerfile</span>
root@rose:~/mynginx<span class="token comment" spellcheck="true">#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>其内容为：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> nginx
<span class="token keyword">RUN</span> echo <span class="token string">'&lt;h1>Hello, Docker!&lt;/h1>'</span> <span class="token punctuation">></span> /usr/share/nginx/html/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p>
<h4 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h4><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>ubuntu</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p>
<p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official" target="_blank" rel="noopener">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href="https://hub.docker.com/_/nginx/" target="_blank" rel="noopener"><code>nginx</code></a>、<a href="https://hub.docker.com/_/redis/" target="_blank" rel="noopener"><code>redis</code></a>、<a href="https://hub.docker.com/_/mongo/" target="_blank" rel="noopener"><code>mongo</code></a>、<a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener"><code>mysql</code></a>、<a href="https://hub.docker.com/_/httpd/" target="_blank" rel="noopener"><code>httpd</code></a>、<a href="https://hub.docker.com/_/php/" target="_blank" rel="noopener"><code>php</code></a>、<a href="https://hub.docker.com/_/tomcat/" target="_blank" rel="noopener"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href="https://hub.docker.com/_/node" target="_blank" rel="noopener"><code>node</code></a>、<a href="https://hub.docker.com/_/openjdk/" target="_blank" rel="noopener"><code>openjdk</code></a>、<a href="https://hub.docker.com/_/python/" target="_blank" rel="noopener"><code>python</code></a>、<a href="https://hub.docker.com/_/ruby/" target="_blank" rel="noopener"><code>ruby</code></a>、<a href="https://hub.docker.com/_/golang/" target="_blank" rel="noopener"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href="https://hub.docker.com/_/ubuntu/" target="_blank" rel="noopener"><code>ubuntu</code></a>、<a href="https://hub.docker.com/_/debian/" target="_blank" rel="noopener"><code>debian</code></a>、<a href="https://hub.docker.com/_/centos/" target="_blank" rel="noopener"><code>centos</code></a>、<a href="https://hub.docker.com/_/fedora/" target="_blank" rel="noopener"><code>fedora</code></a>、<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> scratch
<span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 <a href="https://hub.docker.com/_/swarm/" target="_blank" rel="noopener"><code>swarm</code></a>、<a href="https://quay.io/repository/coreos/etcd" target="_blank" rel="noopener"><code>etcd</code></a>。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href="https://golang.org/" target="_blank" rel="noopener">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
<h4 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h4><p><code>RUN</code> 指令是用来执行命令行命令的（可以理解为启动运行一个镜像容器，并在容器内执行相关命令，然后进行commit操作，之后删除这个容器）。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li>
</ul>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> echo <span class="token string">'&lt;h1>Hello, Docker!&lt;/h1>'</span> <span class="token punctuation">></span> /usr/share/nginx/html/index.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<ul>
<li><em>exec</em> 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式。</li>
</ul>
<p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> debian<span class="token punctuation">:</span>stretch

<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update
<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y gcc libc6<span class="token punctuation">-</span>dev make wget
<span class="token keyword">RUN</span> wget <span class="token punctuation">-</span>O redis.tar.gz <span class="token string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span>
<span class="token keyword">RUN</span> mkdir <span class="token punctuation">-</span>p /usr/src/redis
<span class="token keyword">RUN</span> tar <span class="token punctuation">-</span>xzf redis.tar.gz <span class="token punctuation">-</span>C /usr/src/redis <span class="token punctuation">-</span><span class="token punctuation">-</span>strip<span class="token punctuation">-</span>components=1
<span class="token keyword">RUN</span> make <span class="token punctuation">-</span>C /usr/src/redis
<span class="token keyword">RUN</span> make <span class="token punctuation">-</span>C /usr/src/redis install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>之前说过，Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p>
<p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p>
<p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> debian<span class="token punctuation">:</span>stretch

<span class="token keyword">RUN</span> buildDeps=<span class="token string">'gcc libc6-dev make wget'</span> \
    &amp;&amp; apt<span class="token punctuation">-</span>get update \
    &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y $buildDeps \
    &amp;&amp; wget <span class="token punctuation">-</span>O redis.tar.gz <span class="token string">"http://download.redis.io/releases/redis-5.0.3.tar.gz"</span> \
    &amp;&amp; mkdir <span class="token punctuation">-</span>p /usr/src/redis \
    &amp;&amp; tar <span class="token punctuation">-</span>xzf redis.tar.gz <span class="token punctuation">-</span>C /usr/src/redis <span class="token punctuation">-</span><span class="token punctuation">-</span>strip<span class="token punctuation">-</span>components=1 \
    &amp;&amp; make <span class="token punctuation">-</span>C /usr/src/redis \
    &amp;&amp; make <span class="token punctuation">-</span>C /usr/src/redis install \
    &amp;&amp; rm <span class="token punctuation">-</span>rf /var/lib/apt/lists/* \
    &amp;&amp; rm redis.tar.gz \
    &amp;&amp; rm <span class="token punctuation">-</span>r /usr/src/redis \
    &amp;&amp; apt<span class="token punctuation">-</span>get purge <span class="token punctuation">-</span>y <span class="token punctuation">-</span><span class="token punctuation">-</span>auto<span class="token punctuation">-</span>remove $buildDeps<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 对一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p>
<h4 id="构建镜像-1"><a href="#构建镜像-1" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p>
<p>在 <code>Dockerfile</code> 文件所在目录执行：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker build -t nginx:v3 <span class="token keyword">.</span>
Sending build context to Docker daemon 2.048 kB
Step 1 <span class="token keyword">:</span> FROM nginx
 ---<span class="token operator">></span> e43d811ce2f4
Step 2 <span class="token keyword">:</span> RUN <span class="token keyword">echo</span> <span class="token string">'&lt;h1>Hello, Docker!&lt;/h1>'</span> <span class="token operator">></span> /usr/share/nginx/html/index.html
 ---<span class="token operator">></span> Running <span class="token keyword">in</span> 9cdc27646c7b
 ---<span class="token operator">></span> 44aa4490ce2c
Removing intermediate container 9cdc27646c7b
Successfully built 44aa4490ce2c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p>
<p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker build <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token operator">&lt;</span>上下文路径/URL/-<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们就可以运行这个镜像来创建容器。</p>
<h4 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h4><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p>
<p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 <code>Dockerfile</code> 中这么写：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">COPY</span> ./package.json /app/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p>
<p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker build -t nginx:v3 <span class="token keyword">.</span>
Sending build context to Docker daemon 2.048 kB
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p>
<p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p>
<h4 id="其它-docker-build-的用法"><a href="#其它-docker-build-的用法" class="headerlink" title="其它 docker build 的用法"></a>其它 <code>docker build</code> 的用法</h4><ul>
<li>直接用 Git repo 进行构建</li>
</ul>
<p>或许你已经注意到了，<code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker build https://github.com/twang2218/gitlab-ce-zh.git<span class="token comment" spellcheck="true">#:11.1</span>

Sending build context to Docker daemon 2.048 kB
Step 1 <span class="token keyword">:</span> FROM gitlab/gitlab-ce:11.1.0-ce.0
11.1.0-ce.0: Pulling from gitlab/gitlab-ce
aed15891ba52: Already exists
773ae8583d14: Already exists
<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这行命令指定了构建所需的 Git repo，并且指定默认的 <code>master</code> 分支，构建目录为 <code>/11.1/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
<ul>
<li>用给定的 tar 压缩包构建</li>
</ul>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker build http://server/context.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
<ul>
<li>从标准输入中读取 Dockerfile 进行构建</li>
</ul>
<pre class="line-numbers language-bash"><code class="language-bash">docker build - <span class="token operator">&lt;</span> Dockerfile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">cat</span> Dockerfile <span class="token operator">|</span> docker build -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p>
<ul>
<li>从标准输入中读取上下文压缩包进行构建</li>
</ul>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker build - <span class="token operator">&lt;</span> context.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
<h2 id="Dockerfile-详解"><a href="#Dockerfile-详解" class="headerlink" title="Dockerfile 详解"></a>Dockerfile 详解</h2><p>上面已经介绍了 <code>FROM</code>，<code>RUN</code>，还提及了 <code>COPY</code>, <code>ADD</code>，其实 <code>Dockerfile</code> 功能很强大，它提供了十多个指令。下面我们继续讲解学习其他的指令。</p>
<h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p>
<ul>
<li><code>COPY [--chown=:] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=:] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li>
</ul>
<p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p>
<p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">COPY</span> package.json /usr/src/app/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match" target="_blank" rel="noopener"><code>filepath.Match</code></a> 规则，如：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">COPY</span> hom* /mydir/
<span class="token keyword">COPY</span> hom<span class="token punctuation">?</span>.txt /mydir/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=:</code> 选项来改变文件的所属用户及所属组。</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">COPY</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>chown=55<span class="token punctuation">:</span>mygroup files* /mydir/
<span class="token keyword">COPY</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>chown=bin files* /mydir/
<span class="token keyword">COPY</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>chown=1 files* /mydir/
<span class="token keyword">COPY</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>chown=10<span class="token punctuation">:</span>11 files* /mydir/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p>
<p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p>
<p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> scratch
<span class="token keyword">ADD</span> ubuntu<span class="token punctuation">-</span>xenial<span class="token punctuation">-</span>core<span class="token punctuation">-</span>cloudimg<span class="token punctuation">-</span>amd64<span class="token punctuation">-</span>root.tar.gz /
<span class="token punctuation">...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p>
<p>在 Docker 官方的 <a href="https://yeasy.gitbooks.io/docker_practice/appendix/best_practices.html" target="_blank" rel="noopener">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=:</code> 选项来改变文件的所属用户及所属组。</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">ADD</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>chown=55<span class="token punctuation">:</span>mygroup files* /mydir/
<span class="token keyword">ADD</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>chown=bin files* /mydir/
<span class="token keyword">ADD</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>chown=1 files* /mydir/
<span class="token keyword">ADD</span> <span class="token punctuation">-</span><span class="token punctuation">-</span>chown=10<span class="token punctuation">:</span>11 files* /mydir/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="CMD-容器启动命令"><a href="#CMD-容器启动命令" class="headerlink" title="CMD 容器启动命令"></a>CMD 容器启动命令</h3><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>&quot;</code>，而不要使用单引号。</p>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">CMD</span> echo $HOME<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在实际执行中，会将其变更为：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">CMD</span> <span class="token punctuation">[</span> <span class="token string">"sh"</span><span class="token punctuation">,</span> <span class="token string">"-c"</span><span class="token punctuation">,</span> <span class="token string">"echo $HOME"</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p>
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 <code>CMD</code> 写为：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">CMD</span> service nginx start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程(pid=1)退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件（这样主进程pid=1就是nginx服务进程），并且要求以前台形式运行。比如：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">CMD</span> <span class="token punctuation">[</span><span class="token string">"nginx"</span><span class="token punctuation">,</span> <span class="token string">"-g"</span><span class="token punctuation">,</span> <span class="token string">"daemon off;"</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="ENTRYPOINT-入口点"><a href="#ENTRYPOINT-入口点" class="headerlink" title="ENTRYPOINT 入口点"></a>ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p>
<p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token operator">&lt;</span>ENTRYPOINT<span class="token operator">></span> <span class="token string">"&lt;CMD>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;</code> 有什么好处么？让我们来看几个场景。</p>
<ul>
<li><strong>场景一：让镜像变成像命令一样使用</strong></li>
</ul>
<p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>18.04
<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update \
    &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y curl \
    &amp;&amp; rm <span class="token punctuation">-</span>rf /var/lib/apt/lists/*
<span class="token keyword">CMD</span> <span class="token punctuation">[</span> <span class="token string">"curl"</span><span class="token punctuation">,</span> <span class="token string">"-s"</span><span class="token punctuation">,</span> <span class="token string">"https://ip.cn"</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker run myip
当前 IP：61.148.226.66 来自：北京市 联通<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker run myip -i
docker: Error response from daemon: invalid header field value <span class="token string">"oci runtime error: container_linux.go:247: starting container process caused \"exec: \\\"-i\\\": executable file not found in <span class="token variable">$PATH</span>\"\n"</span><span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s https://ip.cn</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker run myip curl -s https://ip.cn -i<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> ubuntu<span class="token punctuation">:</span>18.04
<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update \
    &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y curl \
    &amp;&amp; rm <span class="token punctuation">-</span>rf /var/lib/apt/lists/*
<span class="token keyword">ENTRYPOINT</span> <span class="token punctuation">[</span> <span class="token string">"curl"</span><span class="token punctuation">,</span> <span class="token string">"-s"</span><span class="token punctuation">,</span> <span class="token string">"https://ip.cn"</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker run myip
当前 IP：61.148.226.66 来自：北京市 联通

$ docker run myip -i
HTTP/1.1 200 OK
Server: nginx/1.8.0
Date: Tue, 22 Nov 2016 05:12:40 GMT
Content-Type: text/html<span class="token punctuation">;</span> charset<span class="token operator">=</span>UTF-8
Vary: Accept-Encoding
X-Powered-By: PHP/5.6.24-1~dotdeb+7.1
X-Cache: MISS from cache-2
X-Cache-Lookup: MISS from cache-2:80
X-Cache: MISS from proxy-2_6
Transfer-Encoding: chunked
Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006
Connection: keep-alive

当前 IP：61.148.226.66 来自：北京市 联通<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p>
<ul>
<li><strong>场景二：应用运行前的准备工作</strong></li>
</ul>
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> alpine<span class="token punctuation">:</span>3.4
<span class="token punctuation">...</span>
<span class="token keyword">RUN</span> addgroup <span class="token punctuation">-</span>S redis &amp;&amp; adduser <span class="token punctuation">-</span>S <span class="token punctuation">-</span>G redis redis
<span class="token punctuation">...</span>
<span class="token keyword">ENTRYPOINT</span> <span class="token punctuation">[</span><span class="token string">"docker-entrypoint.sh"</span><span class="token punctuation">]</span>

<span class="token keyword">EXPOSE</span> 6379
<span class="token keyword">CMD</span> <span class="token punctuation">[</span> <span class="token string">"redis-server"</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/sh</span>
<span class="token punctuation">..</span>.
<span class="token comment" spellcheck="true"># allow the container to be started with `--user`</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$1</span>"</span> <span class="token operator">=</span> <span class="token string">'redis-server'</span> -a <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> -u<span class="token variable">)</span></span>"</span> <span class="token operator">=</span> <span class="token string">'0'</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
    <span class="token function">chown</span> -R redis <span class="token keyword">.</span>
    <span class="token function">exec</span> su-exec redis <span class="token string">"<span class="token variable">$0</span>"</span> <span class="token string">"<span class="token variable">$@</span>"</span>
<span class="token keyword">fi</span>

<span class="token function">exec</span> <span class="token string">"<span class="token variable">$@</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker run -it redis <span class="token function">id</span>
uid<span class="token operator">=</span>0<span class="token punctuation">(</span>root<span class="token punctuation">)</span> gid<span class="token operator">=</span>0<span class="token punctuation">(</span>root<span class="token punctuation">)</span> groups<span class="token operator">=</span>0<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<pre class="line-numbers language-Dockerfie"><code class="language-Dockerfie">ENV VERSION=1.0 DEBUG=on \
    NAME="Happy Feet"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p>
<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">ENV</span> NODE_VERSION 7.2.0

<span class="token keyword">RUN</span> curl <span class="token punctuation">-</span>SLO <span class="token string">"https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz"</span> \
  &amp;&amp; curl <span class="token punctuation">-</span>SLO <span class="token string">"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc"</span> \
  &amp;&amp; gpg <span class="token punctuation">-</span><span class="token punctuation">-</span>batch <span class="token punctuation">-</span><span class="token punctuation">-</span>decrypt <span class="token punctuation">-</span><span class="token punctuation">-</span>output SHASUMS256.txt SHASUMS256.txt.asc \
  &amp;&amp; grep <span class="token string">" node-v$NODE_VERSION-linux-x64.tar.xz\$"</span> SHASUMS256.txt <span class="token punctuation">|</span> sha256sum <span class="token punctuation">-</span>c <span class="token punctuation">-</span> \
  &amp;&amp; tar <span class="token punctuation">-</span>xJf <span class="token string">"node-v$NODE_VERSION-linux-x64.tar.xz"</span> <span class="token punctuation">-</span>C /usr/local <span class="token punctuation">-</span><span class="token punctuation">-</span>strip<span class="token punctuation">-</span>components=1 \
  &amp;&amp; rm <span class="token string">"node-v$NODE_VERSION-linux-x64.tar.xz"</span> SHASUMS256.txt.asc SHASUMS256.txt \
  &amp;&amp; ln <span class="token punctuation">-</span>s /usr/local/bin/node /usr/local/bin/nodejs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。</p>
<p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p>
<h3 id="ARG-构建参数"><a href="#ARG-构建参数" class="headerlink" title="ARG 构建参数"></a>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p>
<p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code> 来覆盖。</p>
<p>在 1.13 之前的版本，要求 <code>--build-arg</code> 中的参数名，必须在 <code>Dockerfile</code> 中用 <code>ARG</code> 定义过了，换句话说，就是 <code>--build-arg</code> 指定的参数，必须在 <code>Dockerfile</code> 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 <code>Dockerfile</code> 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>格式为：</p>
<ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">VOLUME</span> /data<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<pre class="line-numbers language-bash"><code class="language-bash">docker run -d -v mydata:/data xxxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p>
<h3 id="EXPOSE-声明端口"><a href="#EXPOSE-声明端口" class="headerlink" title="EXPOSE 声明端口"></a>EXPOSE 声明端口</h3><p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p>
<p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> cd /app
<span class="token keyword">RUN</span> echo <span class="token string">"hello"</span> <span class="token punctuation">></span> world.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
<p>当然，和 <code>WORKDIR</code> 一样，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">RUN</span> groupadd <span class="token punctuation">-</span>r redis &amp;&amp; useradd <span class="token punctuation">-</span>r <span class="token punctuation">-</span>g redis redis
<span class="token keyword">USER</span> redis
<span class="token keyword">RUN</span> <span class="token punctuation">[</span> <span class="token string">"redis-server"</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a href="https://github.com/tianon/gosu" target="_blank" rel="noopener"><code>gosu</code></a>。</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token comment" spellcheck="true"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span>
<span class="token keyword">RUN</span> groupadd <span class="token punctuation">-</span>r redis &amp;&amp; useradd <span class="token punctuation">-</span>r <span class="token punctuation">-</span>g redis redis
<span class="token comment" spellcheck="true"># 下载 gosu</span>
<span class="token keyword">RUN</span> wget <span class="token punctuation">-</span>O /usr/local/bin/gosu <span class="token string">"https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64"</span> \
    &amp;&amp; chmod +x /usr/local/bin/gosu \
    &amp;&amp; gosu nobody true
<span class="token comment" spellcheck="true"># 设置 CMD，并以另外的用户执行</span>
<span class="token keyword">CMD</span> <span class="token punctuation">[</span> <span class="token string">"exec"</span><span class="token punctuation">,</span> <span class="token string">"gosu"</span><span class="token punctuation">,</span> <span class="token string">"redis"</span><span class="token punctuation">,</span> <span class="token string">"redis-server"</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="HEALTHCHECK-健康检查"><a href="#HEALTHCHECK-健康检查" class="headerlink" title="HEALTHCHECK 健康检查"></a>HEALTHCHECK 健康检查</h3><p>格式：</p>
<ul>
<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li>
<li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li>
</ul>
<p><code>HEALTHCHECK</code> 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p>
<p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p>
<p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p>
<p><code>HEALTHCHECK</code> 支持下列选项：</p>
<ul>
<li><code>--interval=&lt;间隔&gt;</code>：两次健康检查的间隔，默认为 30 秒；</li>
<li><code>--timeout=&lt;时长&gt;</code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li>
<li><code>--retries=&lt;次数&gt;</code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li>
</ul>
<p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> nginx
<span class="token keyword">RUN</span> apt<span class="token punctuation">-</span>get update &amp;&amp; apt<span class="token punctuation">-</span>get install <span class="token punctuation">-</span>y curl &amp;&amp; rm <span class="token punctuation">-</span>rf /var/lib/apt/lists/*
HEALTHCHECK <span class="token punctuation">-</span><span class="token punctuation">-</span>interval=5s <span class="token punctuation">-</span><span class="token punctuation">-</span>timeout=3s \
  <span class="token keyword">CMD</span> curl <span class="token punctuation">-</span>fs http<span class="token punctuation">:</span>//localhost/ <span class="token punctuation">|</span><span class="token punctuation">|</span> exit 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p>
<p>使用 <code>docker build</code> 来构建这个镜像：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker build -t myweb:v1 <span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>构建好了后，我们启动一个容器：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d --name web -p 80:80 myweb:v1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>当运行该镜像后，可以通过 <code>docker container ls</code> 看到最初的状态为 <code>(health: starting)</code>：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker container <span class="token function">ls</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES
03e28eb00bd0        myweb:v1            <span class="token string">"nginx -g 'daemon off"</span>   3 seconds ago       Up 2 seconds <span class="token punctuation">(</span>health: starting<span class="token punctuation">)</span>   80/tcp, 443/tcp     web<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在等待几秒钟后，再次 <code>docker container ls</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker container <span class="token function">ls</span>
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES
03e28eb00bd0        myweb:v1            <span class="token string">"nginx -g 'daemon off"</span>   18 seconds ago      Up 16 seconds <span class="token punctuation">(</span>healthy<span class="token punctuation">)</span>   80/tcp, 443/tcp     web<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code>。</p>
<p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker inspect --format <span class="token string">'{{json .State.Health}}'</span> web <span class="token operator">|</span> python -m json.tool
<span class="token punctuation">{</span>
    <span class="token string">"FailingStreak"</span><span class="token keyword">:</span> 0,
    <span class="token string">"Log"</span><span class="token keyword">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
            <span class="token string">"End"</span><span class="token keyword">:</span> <span class="token string">"2016-11-25T14:35:37.940957051Z"</span>,
            <span class="token string">"ExitCode"</span><span class="token keyword">:</span> 0,
            <span class="token string">"Output"</span><span class="token keyword">:</span> <span class="token string">"&lt;!DOCTYPE html>\n&lt;html>\n&lt;head>\n&lt;title>Welcome to nginx!&lt;/title>\n&lt;style>\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n&lt;/style>\n&lt;/head>\n&lt;body>\n&lt;h1>Welcome to nginx!&lt;/h1>\n&lt;p>If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p>\n\n&lt;p>For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\">nginx.org&lt;/a>.&lt;br/>\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\">nginx.com&lt;/a>.&lt;/p>\n\n&lt;p>&lt;em>Thank you for using nginx.&lt;/em>&lt;/p>\n&lt;/body>\n&lt;/html>\n"</span>,
            <span class="token string">"Start"</span><span class="token keyword">:</span> <span class="token string">"2016-11-25T14:35:37.780192565Z"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>,
    <span class="token string">"Status"</span><span class="token keyword">:</span> <span class="token string">"healthy"</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="ONBUILD-为他人做嫁衣裳"><a href="#ONBUILD-为他人做嫁衣裳" class="headerlink" title="ONBUILD 为他人做嫁衣裳"></a>ONBUILD 为他人做嫁衣裳</h3><p>格式：<code>ONBUILD &lt;其它指令&gt;</code>。</p>
<p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p>
<p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> node<span class="token punctuation">:</span>slim
<span class="token keyword">RUN</span> mkdir /app
<span class="token keyword">WORKDIR</span> /app
<span class="token keyword">COPY</span> ./package.json /app
<span class="token keyword">RUN</span> <span class="token punctuation">[</span> <span class="token string">"npm"</span><span class="token punctuation">,</span> <span class="token string">"install"</span> <span class="token punctuation">]</span>
<span class="token keyword">COPY</span> . /app/
<span class="token keyword">CMD</span> <span class="token punctuation">[</span> <span class="token string">"npm"</span><span class="token punctuation">,</span> <span class="token string">"start"</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p>
<p>如果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p>
<p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> node<span class="token punctuation">:</span>slim
<span class="token keyword">RUN</span> mkdir /app
<span class="token keyword">WORKDIR</span> /app
<span class="token keyword">CMD</span> <span class="token punctuation">[</span> <span class="token string">"npm"</span><span class="token punctuation">,</span> <span class="token string">"start"</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> my<span class="token punctuation">-</span>node
<span class="token keyword">COPY</span> ./package.json /app
<span class="token keyword">RUN</span> <span class="token punctuation">[</span> <span class="token string">"npm"</span><span class="token punctuation">,</span> <span class="token string">"install"</span> <span class="token punctuation">]</span>
<span class="token keyword">COPY</span> . /app/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新。</p>
<p>那么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p>
<p><code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> node<span class="token punctuation">:</span>slim
<span class="token keyword">RUN</span> mkdir /app
<span class="token keyword">WORKDIR</span> /app
<span class="token keyword">ONBUILD</span> <span class="token keyword">COPY</span> ./package.json /app
<span class="token keyword">ONBUILD</span> <span class="token keyword">RUN</span> <span class="token punctuation">[</span> <span class="token string">"npm"</span><span class="token punctuation">,</span> <span class="token string">"install"</span> <span class="token punctuation">]</span>
<span class="token keyword">ONBUILD</span> <span class="token keyword">COPY</span> . /app/
<span class="token keyword">CMD</span> <span class="token punctuation">[</span> <span class="token string">"npm"</span><span class="token punctuation">,</span> <span class="token string">"start"</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p>
<pre class="line-numbers language-docker"><code class="language-docker"><span class="token keyword">FROM</span> my<span class="token punctuation">-</span>node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p>
<h2 id="Dockerfile-定制-LAMP"><a href="#Dockerfile-定制-LAMP" class="headerlink" title="Dockerfile 定制 LAMP"></a>Dockerfile 定制 LAMP</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul>
<li>Linux ubuntu 18.04</li>
<li>Apache 2</li>
<li>MySQL 5.7</li>
<li>PHP 7.2</li>
<li>SSH</li>
<li>系统必备工具（ifconfig+netstat+arp+rarp+route+ping+vim+curl+wget+python等）</li>
<li>部署相应www站点（网站添加普通用户&amp;&amp;权限配置、部署相应数据库）</li>
</ul>
<h3 id="定制脚本"><a href="#定制脚本" class="headerlink" title="定制脚本"></a>定制脚本</h3><ul>
<li>Dockerfile</li>
</ul>
<pre class="line-numbers language-dockerfile"><code class="language-dockerfile"># Basic Image
FROM ubuntu:18.04

# 设置环境变量->构建时非交互式终端(处理'Configuring tzdata'交互输入、在Dockerfile中安装deb软件包时，某些软件将tzdata作为依赖项安装。tzdata会以交互方式提醒用户选择使用位置。)
ENV DEBIAN_FRONTEND=noninteractive

# 设置系统root密码
# 配置并更新软件源
# 安装SSH并支持root ssh
# 搭建LAMP -> Linux + apache2 + Mysql5.7 + PHP7.2 && PHP7.2扩展
# 安装系统常用工具->net-tools(ifconfig/netstat/arp/rarp/route/ipmaddr/iptunnel/mii-tool/nameif/plipconfig/slattach)+ping+vim+curl
# 清除apt缓存 -> /var/lib/apt/lists/*
RUN set -xe \
    && echo "root:root" | chpasswd \
    && cp /etc/apt/sources.list /etc/apt/sources.list.backup \
    && sed -i 's/http:\/\/.*\/ubuntu\//http:\/\/mirrors.tuna.tsinghua.edu.cn\/ubuntu\//g' /etc/apt/sources.list \
    && apt update -y \
    && apt install -y ssh \
    && cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup \
    && sed -ri 's/^#*\s*PermitRootLogin\s*.*/PermitRootLogin yes/g' /etc/ssh/sshd_config \
    && apt install -y apache2 mysql-server-5.7 php7.2 php7.2-gd php7.2-mysql \
    && apt install -y net-tools inetutils-ping vim curl \
    && rm -rf /var/lib/apt/lists/*

# 上下文内容：www/html/* + admin1strat0r.sql + sql.sh -> 复制上下文内容到容器/tmp/中
COPY ./www ./admin1strat0r.sql ./sql.sh ./start.sh /tmp/

# 部署已制作的WWW站点 + 去掉apache2的列目录漏洞(Options Indexes) + 网站添加普通用户&&权限配置
# 设置Mysql root密码 + 执行SQL脚本创建数据库
# 删除缓存(上下文)文件
RUN set -xe \
    && rm -rf /var/www/html \
    && mv /tmp/html /var/www/html \
    && cp /etc/apache2/apache2.conf /etc/apache2/apache2.conf.backup \
    && sed -i 's/Options Indexes FollowSymLinks/Options FollowSymLinks/g' /etc/apache2/apache2.conf \
    && useradd Qftm -m \
    && echo "Qftm:Qftm" | chpasswd \
    && usermod -G Qftm www-data \
    && chown -R Qftm:Qftm /var/www/ \
    && chmod -R 750 /var/www/ \
    && chmod -R 770 /var/www/html/upload_file/ \
    && service mysql restart \
    && mysql -uroot -e "update mysql.user set plugin='mysql_native_password'" \
    && service mysql restart \
    && mysqladmin -uroot password "root" \
    && mkdir /etc/my_init.d/ \
    && mv /tmp/admin1strat0r.sql /tmp/sql.sh /tmp/start.sh -t /etc/my_init.d/ \
    && chmod -R 770 /etc/my_init.d/ \
    && sh /etc/my_init.d/sql.sh \
    && rm -rf /tmp/*

# 服务启动脚本
ENTRYPOINT sh /etc/my_init.d/start.sh

# 声明开放端口
EXPOSE 22 80 3306<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>start.sh</li>
</ul>
<pre class="line-numbers language-sh"><code class="language-sh">#!/bin/bash

# 启动 SSH
service ssh start

# 启动 Apache2
service apache2 start

# 启动 MySQL
service mysql start

while true; do echo Web Server Runing ++++++; sleep 1; done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="容器测试"><a href="#容器测试" class="headerlink" title="容器测试"></a>容器测试</h3><ul>
<li>构建镜像</li>
</ul>
<pre><code>root@rose:~/mydocker# docker build -t webimage:v1.3 .
or
root@rose:~/mydocker# docker build -t webimage:v1.3 . --no-cache</code></pre><p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200411013404649.png" alt="image-20200411013404649"></p>
<ul>
<li>启动容器</li>
</ul>
<pre><code>root@rose:~# docker run -d -p 80:80 webimage:v1.3</code></pre><ul>
<li>查看容器信息</li>
</ul>
<pre><code>docker ps</code></pre><p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200411013729652.png" alt="image-20200411013729652"></p>
<ul>
<li>查看容器状态</li>
</ul>
<pre><code>root@rose:~# docker logs -f --tail=0 e6618707fda5</code></pre><p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200411014501996.png" alt="image-20200411014501996"></p>
<ul>
<li>查看容器内部进程</li>
</ul>
<pre><code>root@rose:~# docker top e6618707fda5</code></pre><ul>
<li>访问网站</li>
</ul>
<p>测试网站是否可以正常访问</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200411014817997.png" alt="image-20200411014817997"></p>
<ul>
<li>登录网站</li>
</ul>
<p>测试网站数据库是否正常连接</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200411015030829.png" alt="image-20200411015030829"></p>
<h1 id="Docker-容器操作"><a href="#Docker-容器操作" class="headerlink" title="Docker 容器操作"></a>Docker 容器操作</h1><p>在前面有了<code>docker pull</code>下来的镜像就可以实例化创建容器了。</p>
<h2 id="启动创建容器"><a href="#启动创建容器" class="headerlink" title="启动创建容器"></a>启动创建容器</h2><p>启动容器有两种方式：一种是基于镜像新建一个容器并启动；另一种是将在终止状态（<code>stopped</code>）下的容器重新启动。</p>
<h3 id="新建容器启动"><a href="#新建容器启动" class="headerlink" title="新建容器启动"></a>新建容器启动</h3><ul>
<li><strong>docker run</strong></li>
</ul>
<p>docker run ：创建一个新的容器并运行一个命令</p>
<p>语法</p>
<pre><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></pre><p>OPTIONS说明</p>
<pre><code>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；
-d: 后台运行容器，并返回容器ID；
-i: 以交互模式运行容器，通常与 -t 同时使用；
-P: 随机端口映射，容器内部端口随机映射到主机的高端口
-p: 指定端口映射，格式为：主机(宿主)端口:容器端口
-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；
--name=&quot;nginx-lb&quot;: 为容器指定一个名称；
--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；
--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；
-h &quot;mars&quot;: 指定容器的hostname；
-e username=&quot;ritchie&quot;: 设置环境变量；
--env-file=[]: 从指定文件读入环境变量；
--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行；
-m :设置容器使用内存最大值；
--net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；
--link=[]: 添加链接到另一个容器；
--expose=[]: 开放一个端口或一组端口；
--volume , -v: 绑定一个卷</code></pre><ul>
<li><strong>使用非root用户运行docker</strong></li>
</ul>
<p>普通用户运行docker需要使用sudo，为了不这样可以将当前普通用户加到docker组里面，然后重启docker与系统，就可以了。</p>
<pre><code>$ sudo groupadd docker  #添加docker组，有的话就不用添加
$ sudo gpasswd -a ${USER} docker  #将普通用户添加到docker组里
$ sudo service docker restart  #重启docker服务
$ sudo reboot   #重启系统使账户修改生效</code></pre><h4 id="非交互式容器"><a href="#非交互式容器" class="headerlink" title="非交互式容器"></a>非交互式容器</h4><ul>
<li>创建命令</li>
</ul>
<pre><code>docker run IMAGE [COMMAND] [ARG...]  #启动一个容器，启动一次执行一次</code></pre><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<pre><code>root@rose:~# docker run ubuntu:latest echo &quot;Hello world&quot;
Hello world</code></pre><ul>
<li>查看容器信息</li>
</ul>
<pre><code>docker ps -a -l  #查看容器，不加参数查看正在运行的容器，-a显示所有容器包括未运行的，-l显示最新创建的容器</code></pre><p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200406222848432.png" alt="image-20200406222848432"></p>
<ul>
<li>查看容器详细信息</li>
</ul>
<pre><code>docker container inspect 容器ID或容器名
or
docker inspect 容器ID或容器名</code></pre><p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200406223049123.png" alt="image-20200406223049123"></p>
<h4 id="交互式容器"><a href="#交互式容器" class="headerlink" title="交互式容器"></a>交互式容器</h4><ul>
<li>创建命令</li>
</ul>
<pre><code>docker run -i -t IMAGE /bin/bash   #启动一个交互式的tty终端

docker run -i -t --name=自定义名 IMAGE /bin/bash #启动一个交互式的tty终端（自定义容器名）</code></pre><p>例如创建一个Ubuntu的交互式bash容器</p>
<pre><code>root@rose:~# docker run -it ubuntu:latest /bin/bash
root@6329cbb6c55d:/# whoami
root
root@6329cbb6c55d:/# pwd
/
root@6329cbb6c55d:/#</code></pre><ul>
<li>退出终止交互式容器</li>
</ul>
<pre><code>exit  #退出并终止容器
or
Ctrl+d #退出并终止容器

root@6329cbb6c55d:/# exit
exit
root@rose:~#</code></pre><ul>
<li>查看容器</li>
</ul>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200406224831476.png" alt="image-20200406224831476"></p>
<h3 id="启动已终止容器"><a href="#启动已终止容器" class="headerlink" title="启动已终止容器"></a>启动已终止容器</h3><p>可以利用<code>docker start</code>来启动一个已经停止的容器</p>
<ul>
<li>启动命令</li>
</ul>
<pre><code>docker start -i 容器ID或容器名  #重新启动已经停止的容器</code></pre><p>例如重新启动上面已经停止的一个交互式容器：<code>zen_montalcini</code></p>
<pre><code>root@rose:~# docker start -i zen_montalcini
root@6329cbb6c55d:/# id
uid=0(root) gid=0(root) groups=0(root)
root@6329cbb6c55d:/#</code></pre><ul>
<li>退出终止容器</li>
</ul>
<pre><code>exit
or
Ctrl+d</code></pre><h2 id="守护式容器"><a href="#守护式容器" class="headerlink" title="守护式容器"></a>守护式容器</h2><p>守护式容器的出现是为了解决容器运行命令之后终止的问题。</p>
<ul>
<li>什么是守护式容器</li>
</ul>
<pre><code>能够长期运行
没有交互式会话  #后台运行
适合运行应用程序和服务</code></pre><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p>
<h3 id="交互式容器转入后台"><a href="#交互式容器转入后台" class="headerlink" title="交互式容器转入后台"></a>交互式容器转入后台</h3><ul>
<li>启动交互式终端转入后台</li>
</ul>
<pre><code>docker run -i -t IMAGE /bin/bash

Ctrl+P+Q   #退出容器，将容器转入到后台运行等同于参数-d

or

docker run -i -t -d IMAGE /bin/bash</code></pre><ul>
<li>查看运行中的容器</li>
</ul>
<pre><code>docker ps</code></pre><p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200406234007447.png" alt="image-20200406234007447"></p>
<ul>
<li>附加到运行中的容器</li>
</ul>
<pre><code>docker attach 容器名  #重新进入运行中的容器</code></pre><pre><code>root@rose:~# docker attach eloquent_johnson
root@ad50a2fb6fe3:/# id
uid=0(root) gid=0(root) groups=0(root)
root@ad50a2fb6fe3:/#</code></pre><ul>
<li>退出终止容器（<strong>attach下</strong>）</li>
</ul>
<pre><code>exit  #退出并停止容器
or
Ctrl+d #退出并停止容器</code></pre><h3 id="非交互式容器转入后台"><a href="#非交互式容器转入后台" class="headerlink" title="非交互式容器转入后台"></a>非交互式容器转入后台</h3><ul>
<li>启动守护式容器</li>
</ul>
<pre><code>docker run -d IMAGE [COMMAND] [ARG...]  #-d表示run命令以后台方式启动一个容器并执行命令，当命令运行结束后容器还是会终止的</code></pre><p>例如运行一个容器执行一段脚本</p>
<pre><code>docker run -d ubuntu:latest /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code></pre><p>执行信息不在终端直接显示，而是转入后台</p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200407000128538.png" alt="image-20200407000128538"></p>
<ul>
<li>查看运行容器日志</li>
</ul>
<p>由于容器转入后台则看不到其相关输出信息，需要通过容器的运行日志来查看</p>
<pre><code>docker logs [-f] [-t] [--tail] 容器名
    -f --follows=true|false 默认为false   #一直追踪日志的变化并返回结果
    -t --timestamps=true|false 默认为false  #返回日志的时间戳
    --tail=“all”  #指定结尾处返回日志的数量，如果不指定则返回所有日志。tail=0显示最新的日志</code></pre><p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200407000149865.png" alt="image-20200407000149865"></p>
<ul>
<li>查看运行容器内的进程</li>
</ul>
<pre><code>docker top 容器名/ID</code></pre><ul>
<li>在运行中的容器内启动新进程（附加进程）</li>
</ul>
<pre><code>docker exec [-d] [-i] [-t] 容器名 [COMMAND] [ARG...]</code></pre><p>附加进程进入交互式bash</p>
<pre><code>root@rose:~# docker exec -it 216c51966f7a95c0b /bin/bash
root@216c51966f7a:/# id
uid=0(root) gid=0(root) groups=0(root)
root@216c51966f7a:/#</code></pre><p>退出交互式bash（<strong>exec下</strong>）</p>
<pre><code>exit  #和attach不同，exec不会终止容器，只是退出</code></pre><ul>
<li>停止守护式容器</li>
</ul>
<pre><code>docker stop 容器名  #给容器发送一个停止信号等待容器停止（停止之后会返回容器的名字/ID）
docker kill 容器名  #直接停止容器（停止之后会返回容器的名字/ID）</code></pre><p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200407000620845.png" alt="image-20200407000620845"></p>
<h2 id="导出与导入"><a href="#导出与导入" class="headerlink" title="导出与导入"></a>导出与导入</h2><p>对于已经创建的容器是可以以归档的形式导出的（相当于导出此时容器的一个快照），同时也可以导入之前导出的容器作为一个新的镜像。</p>
<h3 id="导出容器快照"><a href="#导出容器快照" class="headerlink" title="导出容器快照"></a>导出容器快照</h3><p>导出本地某个容器，可以使用 <code>docker export</code> 命令</p>
<pre><code>root@rose:~# docker export 56b72bf3df65 &gt; ubuntu-latest.tar
root@rose:~# ls
snap  ubuntu-latest.tar
root@rose:~#</code></pre><h3 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h3><p>使用 <code>docker import</code> 导入之前导出的容器快照作为一个新的镜像。新的镜像可以重新创建容器，创建的容器和原来导出的容器一样。</p>
<pre><code>root@rose:~# cat ubuntu-latest.tar | docker import - new/ubuntu:v1.0
sha256:d3c314a215b18e1a8b24113e3fda6d76c73dcad86ac3d2127ed71afe62465915
root@rose:~# docker images
REPOSITORY    TAG           IMAGE ID       CREATED             SIZE
new/ubuntu    v1.0        d3c314a215b1    26 seconds ago       64.2MB
ubuntu        18.04       4e5021d210f6     2 weeks ago         64.2MB
ubuntu        latest      4e5021d210f6     2 weeks ago         64.2MB
root@rose:~#docker -it new/ubuntu:v1.0 /bin/bash</code></pre><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p>
<pre><code>docker import http://example.com/exampleimage.tgz example/imagerepo</code></pre><p>注：用户既可以使用 <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><ul>
<li>删除一个或多个已终止容器</li>
</ul>
<pre><code>docker rm 容器ID或容器名       #只能删除已经停止的容器
or
docker container rm 容器ID或容器名</code></pre><p>例如删除前面创建的那个非交互式容器：<code>competent_brown</code></p>
<p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200406225641419.png" alt="image-20200406225641419"></p>
<ul>
<li>删除所有已终止容器</li>
</ul>
<p>查看终止的容器</p>
<pre><code>docker ps -a 
or
docker container ls -a </code></pre><p>清理所有已经终止的容器</p>
<pre><code>docker container prune</code></pre><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><h3 id="端口映射"><a href="#端口映射" class="headerlink" title="端口映射"></a>端口映射</h3><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<ul>
<li><strong>设置容器的端口映射</strong></li>
</ul>
<pre><code>docker run [-P][-p]

-P ,--publish-all=true|false 默认为false #-P将容器内部开放的网络端口映射到宿主机的一个随机端口上
    docker run -P -i -t ubuntu /bin/bash

-p, publish=[]                #-p映射容器指定的一些端口
    containerPort
        docker run -p 80 -i -t ubuntu /bin/bash
    hostPort:containerPort
        docker run -p 8080:80 -i -t ubuntu /bin/bash
    ip::containerPort
        docker run -p 127.0.0.1::80 -i -t ubuntu /bin/bash
    ip:hostPort:containerPort
        docker run -p 127.0.0.1:8080:80 -i -t ubuntu /bin/bash</code></pre><ul>
<li><strong>不同参数说明</strong></li>
</ul>
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p>
<p>使用 <code>docker container ls -a</code> 或 <code>docker ps -a</code>可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p>
<p>当使用<code>-p</code> 时则可以指定要映射的端口，并且，在一个指定的宿主机端口上只可以绑定一个容器。支持的格式有 <code>containerPort | ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<pre><code>containerPort  #映射所有接口地址的任意端口
#指定容器80端口映射到宿主机的随意一个端口上，作用于宿主机所有的接口地址
    docker run -p 80 -i -t ubuntu /bin/bash

hostPort:containerPort  #映射所有接口地址的指定端口
#指定容器80端口映射到宿主机的8080端口上，作用于宿主机所有的接口地址
    docker run -p 8080:80 -i -t ubuntu /bin/bash

ip::containerPort  #映射到指定地址的任意端口
#指定容器80端口映射到宿主机的随意一个端口上，作用于指定的宿主机地址：127.0.0.1
    docker run -p 127.0.0.1::80 -i -t ubuntu /bin/bash

ip:hostPort:containerPort  #映射到指定地址的指定端口
#指定容器80端口映射到宿主机的8080端口上，作用于指定的宿主机地址：127.0.0.1
    docker run -p 127.0.0.1:8080:80 -i -t ubuntu /bin/bash</code></pre><ul>
<li><strong>查看端口映射配置</strong></li>
</ul>
<p>使用 <code>docker port</code>或 <code>docker ps</code>或<code>docker container ls</code>来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<pre><code>docker port 容器名/ID
docker ps
docker container ls</code></pre><p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200407115414433.png" alt="image-20200407115414433"></p>
<ul>
<li><strong>测试端口映射情况</strong></li>
</ul>
<p>在容器内安装启动apache服务</p>
<pre><code>root@a30200ca3b8a:/# apt update
root@a30200ca3b8a:/# apt install apache2
root@a30200ca3b8a:/# service apache2 restart</code></pre><p>访问容器的apache服务，在宿主机上访问<code>http://127.0.0.1:8080</code>相当于访问了<code>http://容器IP:80</code></p>
<pre><code>curl http://127.0.0.1:8080</code></pre><p><img src="/2019/12/31/Docker-Learning-Handbook/image-20200407120522654.png" alt="image-20200407120522654"></p>
<p>查看容器运行的进程信息</p>
<pre><code>root@rose:~# docker top a30200ca3b8a</code></pre><h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><p>在容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷（Volumes）</li>
<li>挂载主机目录 (Bind mounts)</li>
</ul>
<h3 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<blockquote>
<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 <code>数据卷</code>。</p>
</blockquote>
<ul>
<li>创建一个数据卷</li>
</ul>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker volume create my-vol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>查看所有的 <code>数据卷</code></p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker volume <span class="token function">ls</span>

local               my-vol<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>在主机里使用以下命令可以查看指定 <code>数据卷</code> 的信息</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker volume inspect my-vol
<span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
        <span class="token string">"Driver"</span><span class="token keyword">:</span> <span class="token string">"local"</span>,
        <span class="token string">"Labels"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,
        <span class="token string">"Mountpoint"</span><span class="token keyword">:</span> <span class="token string">"/var/lib/docker/volumes/my-vol/_data"</span>,
        <span class="token string">"Name"</span><span class="token keyword">:</span> <span class="token string">"my-vol"</span>,
        <span class="token string">"Options"</span><span class="token keyword">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>,
        <span class="token string">"Scope"</span><span class="token keyword">:</span> <span class="token string">"local"</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>启动一个挂载数据卷的容器</li>
</ul>
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p>
<p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/webapp</code> 目录。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d -P \
    --name web \
    <span class="token comment" spellcheck="true"># -v my-vol:/wepapp \</span>
    --mount source<span class="token operator">=</span>my-vol,target<span class="token operator">=</span>/webapp \
    training/webapp \
    python app.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>查看数据卷的具体信息</li>
</ul>
<p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker inspect web<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>数据卷</code> 信息在 “Mounts” Key 下面</p>
<pre class="line-numbers language-json"><code class="language-json"><span class="token property">"Mounts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
        <span class="token property">"Type"</span><span class="token operator">:</span> <span class="token string">"volume"</span><span class="token punctuation">,</span>
        <span class="token property">"Name"</span><span class="token operator">:</span> <span class="token string">"my-vol"</span><span class="token punctuation">,</span>
        <span class="token property">"Source"</span><span class="token operator">:</span> <span class="token string">"/var/lib/docker/volumes/my-vol/_data"</span><span class="token punctuation">,</span>
        <span class="token property">"Destination"</span><span class="token operator">:</span> <span class="token string">"/app"</span><span class="token punctuation">,</span>
        <span class="token property">"Driver"</span><span class="token operator">:</span> <span class="token string">"local"</span><span class="token punctuation">,</span>
        <span class="token property">"Mode"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
        <span class="token property">"RW"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token property">"Propagation"</span><span class="token operator">:</span> <span class="token string">""</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>删除数据卷</li>
</ul>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker volume <span class="token function">rm</span> my-vol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>
<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker volume prune<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="挂载主机目录"><a href="#挂载主机目录" class="headerlink" title="挂载主机目录"></a>挂载主机目录</h3><ul>
<li>挂载一个主机目录作为数据卷</li>
</ul>
<p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d -P \
    --name web \
    <span class="token comment" spellcheck="true"># -v /src/webapp:/opt/webapp \</span>
    --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span>/src/webapp,target<span class="token operator">=</span>/opt/webapp \
    training/webapp \
    python app.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/opt/webapp</code>目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p>
<p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker run -d -P \
    --name web \
    <span class="token comment" spellcheck="true"># -v /src/webapp:/opt/webapp:ro \</span>
    --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span>/src/webapp,target<span class="token operator">=</span>/opt/webapp,readonly \
    training/webapp \
    python app.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/opt/webapp</code> 目录新建文件，会显示如下错误</p>
<pre class="line-numbers language-bash"><code class="language-bash">/opt/webapp <span class="token comment" spellcheck="true"># touch new.txt</span>
touch: new.txt: Read-only <span class="token function">file</span> system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>查看数据卷的具体信息</li>
</ul>
<p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker inspect web<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>挂载主机目录</code> 的配置信息在 “Mounts” Key 下面</p>
<pre class="line-numbers language-json"><code class="language-json"><span class="token property">"Mounts"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
        <span class="token property">"Type"</span><span class="token operator">:</span> <span class="token string">"bind"</span><span class="token punctuation">,</span>
        <span class="token property">"Source"</span><span class="token operator">:</span> <span class="token string">"/src/webapp"</span><span class="token punctuation">,</span>
        <span class="token property">"Destination"</span><span class="token operator">:</span> <span class="token string">"/opt/webapp"</span><span class="token punctuation">,</span>
        <span class="token property">"Mode"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span>
        <span class="token property">"RW"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        <span class="token property">"Propagation"</span><span class="token operator">:</span> <span class="token string">"rprivate"</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">]</span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>挂载一个本地主机文件作为数据卷</li>
</ul>
<p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ docker run --rm -it \
   <span class="token comment" spellcheck="true"># -v $HOME/.bash_history:/root/.bash_history \</span>
   --mount type<span class="token operator">=</span>bind,source<span class="token operator">=</span><span class="token variable">$HOME</span>/.bash_history,target<span class="token operator">=</span>/root/.bash_history \
   ubuntu:18.04 \
   <span class="token function">bash</span>

root@2affd44b4667:/<span class="token comment" spellcheck="true"># history</span>
1  <span class="token function">ls</span>
2  diskutil list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样就可以记录在容器输入过的命令了。</p>
<h1 id="Docker-仓库管理"><a href="#Docker-仓库管理" class="headerlink" title="Docker 仓库管理"></a>Docker 仓库管理</h1><p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>dl.dockerpool.com/username/ubuntu</code> 来说，<code>dl.dockerpool.com</code> 是注册服务器地址，<code>username/ubuntu</code> 是仓库名。</p>
<p>大部分时候，并不需要严格区分这两者的概念。</p>
<h2 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h2><p>目前 Docker 官方维护了一个公共仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，其中已经包括了数量超过 15,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>你可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com</a> 免费注册一个 Docker 账号。</p>
<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>可以通过 <code>docker logout</code> 退出登录。</p>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><p>可以通过 <code>docker search</code> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p>
<h3 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h3><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p>
<pre><code>$ docker tag ubuntu:18.04 username/ubuntu:18.04
$ docker image ls
REPOSITORY       TAG       IMAGE ID            CREATED             SIZE
ubuntu           18.04    275d79972a86        6 days ago          94.6MB
username/ubuntu  18.04    275d79972a86        6 days ago          94.6MB
$ docker push username/ubuntu:18.04
$ docker search username
NAME           DESCRIPTION      STARS     OFFICIAL    AUTOMATED
username/ubunt</code></pre><p>完成上述操作之后查看dockerhub中自己的仓库就可以看到刚刚推送的镜像。</p>
<h1 id="Docker-底层实现"><a href="#Docker-底层实现" class="headerlink" title="Docker 底层实现"></a>Docker 底层实现</h1><p>Docker 容器和 LXC 容器很相似，所提供的安全特性也差不多。</p>
<p>LXC 为 Linux Container 的简写，内部采用了Linux内核Namespace和Cgroups两个特性，可以提供轻量级的虚拟化，以便隔离进程和资源，而且不需要提供指令解释机制以及全虚拟化的其他复杂性。</p>
<p>Docker基于Linux kernel的Namespace，CGroups，UnionFileSystem等技术封装成一种自定义的容器格式，用于提供一整套虚拟运行环境。</p>
<p>使用容器可以有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>命名空间（<a href="https://en.wikipedia.org/wiki/Linux_namespaces" target="_blank" rel="noopener">Namespace</a>、<a href="http://man7.org/linux/man-pages/man7/namespaces.7.html" target="_blank" rel="noopener">Linux man</a>）是 Linux 内核一个强大的特性，从Linux内核2.6.27版本开始已经支持LXC。每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。</p>
<ul>
<li>pid 命名空间</li>
</ul>
<p>不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。所有的 LXC 进程在 Docker 中的父进程为 Docker 进程，每个 LXC 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。</p>
<ul>
<li>net 命名空间</li>
</ul>
<p>有了 pid 命名空间，每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备，IP 地址，路由表，/proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。</p>
<ul>
<li>ipc 命名空间</li>
</ul>
<p>容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication - IPC)， 包括信号量、消息队列和共享内存等。然而同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。</p>
<ul>
<li>mnt 命名空间</li>
</ul>
<p>类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个命名空间中的容器在 /proc/mounts 的信息只包含所在命名空间的 mount point。</p>
<ul>
<li>uts 命名空间</li>
</ul>
<p>UTS(“UNIX Time-sharing System”) 命名空间允许每个容器拥有独立的 hostname 和 domain name， 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。</p>
<ul>
<li>user 命名空间</li>
</ul>
<p>每个容器可以有不同的用户和组 id， 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。</p>
<h2 id="控制组"><a href="#控制组" class="headerlink" title="控制组"></a>控制组</h2><p>控制组（<a href="https://en.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroups</a>、<a href="http://man7.org/linux/man-pages/man7/cgroups.7.html" target="_blank" rel="noopener">Linux man</a>）是 Linux 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p>
<p>控制组技术最早是由 Google 的程序员在 2006 年提出，Linux 内核自 2.6.24 开始支持。</p>
<p>控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。</p>
<h2 id="联合文件系统"><a href="#联合文件系统" class="headerlink" title="联合文件系统"></a>联合文件系统</h2><p>联合文件系统（<a href="https://en.wikipedia.org/wiki/UnionFS" target="_blank" rel="noopener">UnionFS</a>）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p>
<p>Docker 中使用的 AUFS（Advanced Multi-Layered Unification Filesystem）就是一种联合文件系统。 <code>AUFS</code> 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 <code>AUFS</code> 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p>
<p>Docker 目前支持的联合文件系统包括 <code>OverlayFS</code>, <code>AUFS</code>, <code>Btrfs</code>, <code>VFS</code>, <code>ZFS</code> 和 <code>Device Mapper</code>。</p>
<p>各 Linux 发行版 Docker 推荐使用的存储驱动如下表。</p>
<table>
<thead>
<tr>
<th align="left">Linux 发行版</th>
<th align="left">Docker 推荐使用的存储驱动</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Docker CE on Ubuntu</td>
<td align="left"><code>overlay2</code> (16.04 +)</td>
</tr>
<tr>
<td align="left">Docker CE on Debian</td>
<td align="left"><code>overlay2</code> (Debian Stretch), <code>aufs</code>, <code>devicemapper</code></td>
</tr>
<tr>
<td align="left">Docker CE on CentOS</td>
<td align="left"><code>overlay2</code></td>
</tr>
<tr>
<td align="left">Docker CE on Fedora</td>
<td align="left"><code>overlay2</code></td>
</tr>
</tbody></table>
<p>在可能的情况下，<a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/" target="_blank" rel="noopener">推荐</a> 使用 <code>overlay2</code> 存储驱动，<code>overlay2</code> 是目前 Docker 默认的存储驱动，以前则是 <code>aufs</code>。你可以通过配置来使用以上提到的其他类型的存储驱动。</p>
<h1 id="Docker-安全机制"><a href="#Docker-安全机制" class="headerlink" title="Docker 安全机制"></a>Docker 安全机制</h1><p>Docker的安全机制有很多种：<a href="http://man7.org/linux/man-pages/man7/capabilities.7.html" target="_blank" rel="noopener">Linux Capability</a>、AppArmor、SELinux、Seccomp等等</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><pre><code>https://docs.docker.com/

https://www.bilibili.com/video/BV1pW411G7r3

https://www.runoob.com/docker/docker-tutorial.html

https://yeasy.gitbooks.io/docker_practice/introduction/what.html

https://docs.docker.com/engine/reference/builder/

https://docs.docker.com/develop/develop-images/dockerfile_best-practices/

https://github.com/docker-library/docs</code></pre>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Qftm</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://Qftm.github.io/2019/12/31/Docker-Learning-Handbook/">http://Qftm.github.io/2019/12/31/Docker-Learning-Handbook/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">Qftm</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Handbook/">
                                    <span class="chip bg-color">Handbook</span>
                                </a>
                            
                                <a href="/tags/Docker/">
                                    <span class="chip bg-color">Docker</span>
                                </a>
                            
                                <a href="/tags/Cloud/">
                                    <span class="chip bg-color">Cloud</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2020/01/01/small-and-medium-sized-enterprise-firewall-deployment/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/firewalld-1.jpg" class="responsive-img" alt="中小型企业级防火墙部署">
                        
                        <span class="card-title">中小型企业级防火墙部署</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            前言2020年第一篇文章，先祝大家新年快乐，2020年暴瘦、暴富~，新年第一天就在做项目QAQ，在这里分享项目的一部分，其它部分将在后面开源分享，欢迎大家一起交流分享
防火墙防火墙是由软件和硬件组成的系统，它处于安全的网络(通常是内部局域网
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-01-01
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE/" class="post-category">
                                    安全建设
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Firewalld/">
                        <span class="chip bg-color">Firewalld</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/11/22/PhpStudyBackDoor2019/">
                    <div class="card-image">
                        
                        <img src="/medias/featureimages/phpstudy-1.jpg" class="responsive-img" alt="PhpStudy BackDoor2019 深度分析">
                        
                        <span class="card-title">PhpStudy BackDoor2019 深度分析</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            关于《PhpStudy BackDoor》风波已经过去有一段时间了，由于，前段时间一直忙于其它事情QAQ，今天有时间对该事件重新回溯&amp;深度分析。
严正声明：本文仅限于技术讨论与分享，严禁用于非法途径
背景分析2019年9月20日，杭
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-11-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/" class="post-category">
                                    代码审计
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%9C%A8%E9%A9%AC%E5%90%8E%E9%97%A8/">
                        <span class="chip bg-color">木马后门</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + 'From: Qftm<br />'
            + 'Author: Qftm<br />'
            + 'Link: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2018</span>
            <a href="/about" target="_blank">Qftm</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">370.8k</span>&nbsp;字
            
            
            
            
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link ">
    <a href="https://github.com/Qftm" 
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:Qftmbin@gmail.com" 
        <i class="fas fa-envelope-open"></i>
    </a>





    <a href="https://twitter.com/Qftmer" 
        <i class="fab fa-twitter"></i>
    </a>









</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/search.xml", 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    

    

    

    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
